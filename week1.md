# Week 1 릴레이 프로젝트

> **Team 67**
> 
> J156, J188, J234, S037

## ❓ Quests

### 1. 하루 1회 회고하기

**💡 달성 기준**
> 하루 1회 회고하기. 단, 짧더라도 정직한 감정, 생각, 경험이 담겨 있을 것.</br>
> 회고는 혼자 마음속으로 해도 좋고, 공유해도 좋음. 퀘스트 받는자의 마음대로.

**💡 배경**

- **AI에게 질문하는 습관이 일상화**되면서, 편리함은 얻었지만 그만큼 **스스로 사고하고 고민하는 힘이 약해지고 있음**을 자각함.
- 그러나 동시에, AI는 더 이상 피할 수 없는 기술 흐름이며, **완전히 배제하는 것도 비현실적**이라 판단함.
- 그래서 AI를 **어디까지 활용하고 어디서부터는 나 스스로 사고해야 하는지에 대한 경계**에 대해 고민하게 됨.
- 특히, **하루 회고나 자가 성찰**과 같이 **내면을 돌아보는 과정마저 AI에 의존하**고 있다는 사실에서 위기감을 느낌.
- 결국 **AI를 활용하되, 나 자신을 잃지 않기 위한 방법**이 필요하다고 느끼게 됨.

**💡 목적**

- **AI 없이 스스로 생각하고 정리하는 연습**을 통해 주체적인 사고를 회복하고 유지하기 위함.
- 특히 **자기 성찰이나 회고의 영역만큼은 나 자신의 언어로 표현해보는 시간**을 갖고자 함.
- “AI 없이도 나는 나에 대해 생각하고 표현할 수 있다”는 **자기 인식력과 판단력을 기르는 훈련**이 목적.

---

### 2. AI에게 더 좋은 질문 알기

**💡 달성 기준**
> - 동일한 주제에 대해 프롬프트 2개 이상 작성
> - AI에게 아래와 같은 내용을 질문 후 결과 확인</br>
>   “이 중에서 가장 좋은 질문은 무엇이며, 이유는?”
> - AI가 제시한 이유를 읽어보고, 좋은 프롬프트 특징 최소 1개 이상 메모
> - (추가로, 발견한 특징을 팀원들과 공유하면 더 좋음)


**💡 배경**

- AI는 입력된 프롬프트의 품질에 따라 답변의 정확도와 깊이가 크게 달라짐.
- 개발자에게 중요한 역량 중 하나는 좋은 질문을 던지는 능력이며, 이를 위해 다양한 질문 방식을 시도해보고 차이를 경험하는 것이 필요하다고 생각.

**💡 목적**

- 동일한 주제를 AI에게 여러 방식으로 질문하고, 어떤 질문이 가장 좋은 답변을 이끌어내는지 확인.
- 좋은 프롬프트가 갖추어야 할 요소(맥락, 구체성, 단계적 요구 등)를 직접 체감하고, 효과적인 질문이 뭘 지 감을 찾아가는 것.

---

### 3. 개념을 잘 이해했는지 물어보기

**💡 달성 기준**
> - 개념을 학습한 것을 정리
> - AI에게 잘 이해한 것인지 질문하기
> - 검토받은 내용을 기반으로 학습 내용 다시 정리


**💡 배경**

- 개념을 잘 설명할 수 있으면 그 개념에 대한 이해도를 높일 수 있음. 
- AI와 토론하며 개념을 이해할 수 있는 도구로 활용하면 학습과 성장에 도움이 될 것으로 보임
- 학습과 성장의 도구로 AI를 활용하는 사례가 될 수 있음


**💡 목적**

- AI에게 이해한 것을 설명하여 내가 그 개념을 잘 알고 있는지 메타인지를 할 수 있는 도구로 활용
- 설명하는 행위 자체로도 개념 이해에 많은 도움이 됨

---

### 4. AI에게 할 질문 내용 개선 요청하기

**💡 달성 기준**
> - 하루에 한 번
> - AI에게 질문하기 전에
> - 그 질문이 효과적인지  AI에게 물어보고
> - 그렇지 않다면 개선해달라고 요청한다.
> - 기존의 질문을 가지고 질문한다.
> - 개선된 질문을 가지고 질문한다.
> - 각각의 질문과 답변을 양식에 기록한다.
> - 각각의 답변의 차이에 대해 양식에 기록한다.
> - 기록한 양식을 링크로 공유한다.

[예시](https://docs.google.com/document/d/1_3KtkESluOEbdcso9SEwdoU6z-hWXg8EomyL4iuBwAU/edit?tab=t.flnm3br5nrex)

[양식](https://docs.google.com/document/d/1liia1Rir4WXHZqQj3PhQQGDTKVhUbv7yIMhZ15aX4LE/edit?tab=t.0)

**💡 배경**

- 효율적인 학습 및 AI의 적절한 활용을 위해, 효과적인 프롬프트의 작성은, 개발자들에게 있어서 중요한 역량으로 대두되고 있는 추세이다.

**💡 목적**

- 더 나은 질문이 무엇인지 AI에게 직접 물어보면서, 프롬프트 작성 능력을 향상시키는 것을 목적으로 한다.


# Week 1 릴레이 프로젝트 수행

> **Team 62**
> 
> J013, J176, J217, S031

## J176

❗️수행할 미션: AI에게 더 좋은 질문 알기

<details>
  
<summary>07.21(월)</summary>

## "SOLID원칙에 대해 알려줘" vs "객체지향의 원칙에 대해 알려줘"
### 어떤 질문이 더 좋은 질문일까?

### 질문의 명확성 비교

| 질문                               | 명확성        | 범위                |
|:------------------------------------|:-------------|:--------------------|
| SOLID원칙에 대해 알려줘              | 매우 명확함   | SOLID 5가지 원칙 한정 |
| 객체지향의 원칙에 대해 알려줘        | 다소 포괄적임 | OOP 전반의 다양한 원칙 |

#### SOLID원칙에 대해 알려줘
- **구체적 주제** 한정 : SOLID라는 5가지 객체지향 설계 원칙을 직접적으로 묻는 질문.
- **관련 정보** : SRP(단일 책임 원칙), OCP(개방 폐쇄 원칙), LSP(리스코프 치환 원칙), ISP(인터페이스 분리 원칙), DIP(의존성 역전 원칙).
- **답변의 초점**이 뚜렷함: 누구나 SOLID에 대해서만 상세하게 설명할 수 있음.

#### 객체지향의 원칙에 대해 알려줘
- **범위가 넓음:** 객체지향 설계에 관련된 여러 원칙(OOP 4대 특성, SOLID, GRASP 등)을 모두 포함할 수 있음.
- **모호성 존재:** 답변하는 사람이나 맥락에 따라 답변이 달라질 수 있음.
- **상황에 따라 다양한 해석**이 가능. 예를 들어, 캡슐화·상속·다형성·추상화와 같은 기본 특성부터 GRASP, SOLID, 그 외 패턴까지 포함될 수 있음.

### 결론: 더 좋은 질문은?

- **더 좋은 질문은 "SOLID원칙에 대해 알려줘"**입니다.
  - 이유: **답변의 범위가 명확하고, 질문자가 원하는 정보가 구체적으로 드러납니다.** 답변하는 입장에서도 정확하게 원하는 정보를 전달할 수 있습니다.
  - 반면, "객체지향의 원칙"은 질문의 스펙트럼이 넓어 원하는 방향과 깊이를 맞추기 어렵기 때문입니다.

### 상황별 활용 팁

- **배경지식이 충분하거나 특정 내용을 명확히 알고 싶을 때**: 구체적으로 “SOLID 원칙” 등 특정 개념을 지정해서 묻는 것이 효과적입니다.
- **전체적 흐름이나 큰 그림이 궁금할 때**: “객체지향의 원칙”처럼 포괄적으로 묻고, 이후 추가 질문을 통해 세부 주제로 좁혀나가는 것도 한 방법입니다.

</details>

<details>

<summary>07.22(화)</summary>

## “Mocha와 Jest를 비교해줘” vs “자바스크립트 단위테스트 라이브러리에 대해 알려줘”  
### 어떤 질문이 더 좋은가?

이 두 질문은 목적과 깊이에 따라 적합성이 다릅니다. 아래에서 각각의 장점을 비교하여 어느 질문이 더 “좋은 질문”인지 상황에 따라 조명합니다.

### 1. "Mocha와 Jest를 비교해줘"
- **장점**
  - 특정 두 프레임워크의 장단점을 명확히 파악할 수 있습니다.
  - 프로젝트에서 도입하거나 대체할 때 의사결정이 쉬워집니다.
  - 실제 개발 현장에서 자주 쓰이는 실질적인 비교 결과를 제공합니다.
  - 다음과 같은 대표적인 차이점과 특성을 빠르게 얻을 수 있습니다.
    - Jest는 설정이 거의 필요 없는 올인원(flush, snapshot, mocking 내장) 솔루션이고 React와 프론트엔드 테스트에 강함
    - Mocha는 더욱 유연하고, 백엔드(Node.js)와 커스텀화가 필요한 환경에 강함
    - 성능이나 에코시스템, 커뮤니티 크기 등도 한눈에 비교 가능
- **적합한 경우**
  - 이미 어느 정도 단위 테스트 도구에 대한 지식이 있으며, 실제 도입 선택이 필요한 상황
  - 특정 프레임워크를 들어본 적이 있고 실질적인 선택이 필요한 경우

### 2. "자바스크립트 단위테스트 라이브러리에 대해 알려줘"
- **장점**
  - 다양한 선택지를 넓게 탐색할 수 있습니다.
  - Mocha, Jest 외에도 Jasmine, AVA, Cypress, QUnit, Testing Library 등 다양한 트렌드와 용도를 폭넓게 파악할 수 있습니다.
  - 각 프레임워크의 특징, 사용처, 인기, 생태계, 커뮤니티 등 전체적인 그림을 얻기에 유리합니다.
- **적합한 경우**
  - 단위 테스트에 처음 입문하거나 전체적인 시장 지형을 알고 싶을 때
  - 프로젝트의 요구사항에 맞춰 최적의 프레임워크를 선정하는 초기 조사 단계

### 표: 질문별 특징 비교

| 질문                          | 목적 및 깊이               | 적합한 상황                                               | 주요 특징                                                            |
|-----------------------------|------------------------|---------------------------------------------------------|--------------------------------------------------------------------|
| Mocha와 Jest를 비교해줘         | 구체적, 실전 중심 비교         | 실질 도입/교체, 선택 대상이 정해져 있을 때                     | 빠른 의사결정 지원, 장/단점 명확, 실무 활용도 높음                       |
| 자바스크립트 단위테스트 라이브러리 소개 | 넓은 범위, 개요 중심            | 입문, 초기 조사, 다양한 선택지 탐색 필요할 때                      | 전체 지형 파악, 여러 대안 제시, 프레임워크별 특징 정리                     |

## 결론: 어떤 질문이 더 좋은가?

- **상황에 따라 다릅니다.**  
  - 이미 JavaScript 테스트 경험이 있고 특정 프레임워크를 놓고 고민 중이라면 "Mocha와 Jest를 비교해줘"가 실질적이고 구체적인 답을 얻기에 더 좋은 질문입니다.
  - 단위 테스트 자체가 낯설거나, 도구 선택 전 폭넓은 조사가 필요한 경우라면 "자바스크립트 단위테스트 라이브러리에 대해 알려줘"가 더 많은 정보를 줄 수 있습니다.

- **실무에서는 "비교 질문"이 더 효율적**
  - 실제로 도입하거나 팀 내에서 표준 도구를 선정해야 할 때는 구체적인 비교 질문이 더 실용적이고 결정에 도움이 됩니다.

- **다양한 대안을 알아야 할 때는 "전체 소개" 질문 적합**
  - 트렌드, 테스트 방식, 각 프레임워크 특징 등 큰 그림을 보려면 "전체 라이브러리 소개" 질문이 적합합니다.

> 즉, **명확한 목적이 있다면 구체적 비교 질문이 더 좋은 질문**이 되고,  
> **지식 습득 및 시장 조사가 목적이라면 폭넓은 소개 질문이 더 효율적**입니다.

</details>

<details>

<summary>07.23(수)</summary>

## 1. 질문 비교

| 질문 | 내용 |
|---|---|
| 함수형 프로그래밍에 대해 알려줘. | 함수형 프로그래밍 전체 개념, 특징, 원리, 이점 등 넓은 범위에 대한 설명 요청 |
| 순수 함수, 불변성, 참조 투명성에 대해 알려줘 | 함수형 프로그래밍의 핵심 개념 3가지를 구체적으로 설명 요청 |

## 2. 각 질문별 답변 예시

### 함수형 프로그래밍에 대해 알려줘

함수형 프로그래밍은 수학의 함수 개념을 바탕으로 하여, **순수 함수(pure function)**와 **불변성(immutability)** 등 특징을 강조하는 프로그래밍 패러다임입니다. 상태 변이(mutation) 없이 데이터를 처리하며, 부수효과(side effect)를 최소화하여 프로그램의 예측 가능성과 안정성을 높입니다.

### 순수 함수, 불변성, 참조 투명성에 대해 알려줘

- **순수 함수(pure function)**: 같은 입력에 대해 항상 같은 출력을 내며, 함수 실행 외부에 영향을 주거나 받지 않는 함수.
- **불변성(immutability)**: 데이터가 한 번 생성된 이후에는 변경될 수 없는 성질로, 변경 시 새로운 값을 생성하여 반환.
- **참조 투명성(referential transparency)**: 어떤 식(expression)을 그 값 자체로 치환해도 프로그램의 결과가 달라지지 않는 성질.

## 3. 더 좋은 질문은?

"**순수 함수, 불변성, 참조 투명성에 대해 알려줘**"가 더 좋은 질문입니다.

### 그 이유

- **구체성**: 원하는 정보가 명확하게 드러나서, 답변자가 핵심을 빠르고 효과적으로 설명할 수 있습니다.
- **학습 효과**: 함수형 프로그래밍을 실질적으로 구성하는 중요한 개념을 직접적으로 이해할 수 있습니다.
- **심층적 이해**: 단순한 개념 소개가 아닌, 각 원리의 용도와 차이점까지 파악할 수 있어 응용에 도움이 됩니다.

반면, "함수형 프로그래밍에 대해 알려줘."는 범위가 넓어 막연한 설명이 될 수 있으며, 구체적인 궁금증 혹은 학습 목적을 만족시키기 어렵습니다. 

## 결론

- **함수형 프로그래밍 전체의 개요**가 궁금하다면 첫 번째 질문도 괜찮지만,
- **핵심 개념의 이해나 실질적 적용**을 원한다면 두 번째 질문이 훨씬 효율적이며, 더 좋은 질문입니다.

</details>


## J217

❗️수행할 미션: 개념을 잘 이해했는지 물어보기

<details>
  
<summary>7/21(월)</summary>

- 저는 Day6 미션을 진행하면서 혼자 정리한 개념을 검토받고, 다시 더 보완해서 간단히 정리해달라는 퀘스트를 함께 수행해보았습니다.
- 입력 프롬프트
```
- 내가 개념을 학습한 것을 정리해서 너에게 줄거야.
- 내가 정리한 내용을 바탕으로 잘 이해했는지 확인해줘.
- 검토받은 내용을 기반으로 학습 내용을 다시 간단히 정리해줘 아래는 내가 학습한 내용을 정리한거야.
..(인터페이스 구현 vs. 추상 클래스 상속 개념을 정리한 내용)
```
- Claude AI 답변

```
**이해 상태 검토**
전반적으로 잘 정리하셨습니다! 핵심 개념들을 정확하게 파악하고 계십니다. 몇 가지 보완할 점과 정확히 짚고 넘어갈 부분들을 말씀드리겠습니다.

**잘 이해하신 부분:**
인터페이스가 컴파일 타임에만 존재하고 JS 코드를 생성하지 않는다는 점
추상 클래스가 런타임에 실제 JS 클래스를 생성한다는 점
추상 클래스에서 생성자, 기본 구현, 접근 한정자 사용 가능하다는 점
사용 시기에 대한 판단 기준

**보완이 필요한 부분:**
"인터페이스가 값 수준에서 객체, 배열, 함수, 클래스, 클래스 인스턴스를 정의할 수 있다"는 표현이 조금 모호합니다. 더 정확히는 "인터페이스는 객체의 형태, 함수의 시그니처, 클래스의 구조 등 다양한 타입을 정의할 수 있다"고 하는 것이 좋겠습니다.
추상 클래스의 특징 중 "추상 메서드"에 대한 언급이 빠져있습니다. 추상 클래스는 구현이 없는 추상 메서드를 가질 수 있고, 이를 상속받는 클래스에서 반드시 구현해야 합니다.

**학습 내용 간단 정리**
인터페이스 vs 추상 클래스
- 인터페이스 (Interface)
타입의 형태만 정의하는 계약서 역할
컴파일 타임에만 존재, 런타임에는 JS 코드 생성 안함
객체, 함수, 클래스 등 다양한 타입 구조 정의 가능
가볍고 범용적인 타입 체크 용도

- 추상 클래스 (Abstract Class)
클래스만 정의 가능한 특수한 클래스
런타임에 실제 JS 클래스로 컴파일됨
생성자, 기본 구현, 추상 메서드, 접근 한정자 모두 사용 가능
공통 구현을 포함한 상속 구조 설계 시 사용

- 선택 기준
공통 구현이 필요하면 → 추상 클래스
단순히 타입 구조 정의가 목적이면 → 인터페이스

핵심 개념을 잘 이해하고 계시네요!
```


</details>

## S031

❗️수행할 미션: 하루 1회 회고하기


