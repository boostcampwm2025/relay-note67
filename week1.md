# Week 1 릴레이 프로젝트

> **Team 67**
> 
> J156, J188, J234, S037

## ❓ Quests

### 1. 하루 1회 회고하기

**💡 달성 기준**
> 하루 1회 회고하기. 단, 짧더라도 정직한 감정, 생각, 경험이 담겨 있을 것.</br>
> 회고는 혼자 마음속으로 해도 좋고, 공유해도 좋음. 퀘스트 받는자의 마음대로.

**💡 배경**

- **AI에게 질문하는 습관이 일상화**되면서, 편리함은 얻었지만 그만큼 **스스로 사고하고 고민하는 힘이 약해지고 있음**을 자각함.
- 그러나 동시에, AI는 더 이상 피할 수 없는 기술 흐름이며, **완전히 배제하는 것도 비현실적**이라 판단함.
- 그래서 AI를 **어디까지 활용하고 어디서부터는 나 스스로 사고해야 하는지에 대한 경계**에 대해 고민하게 됨.
- 특히, **하루 회고나 자가 성찰**과 같이 **내면을 돌아보는 과정마저 AI에 의존하**고 있다는 사실에서 위기감을 느낌.
- 결국 **AI를 활용하되, 나 자신을 잃지 않기 위한 방법**이 필요하다고 느끼게 됨.

**💡 목적**

- **AI 없이 스스로 생각하고 정리하는 연습**을 통해 주체적인 사고를 회복하고 유지하기 위함.
- 특히 **자기 성찰이나 회고의 영역만큼은 나 자신의 언어로 표현해보는 시간**을 갖고자 함.
- “AI 없이도 나는 나에 대해 생각하고 표현할 수 있다”는 **자기 인식력과 판단력을 기르는 훈련**이 목적.

---

### 2. AI에게 더 좋은 질문 알기

**💡 달성 기준**
> - 동일한 주제에 대해 프롬프트 2개 이상 작성
> - AI에게 아래와 같은 내용을 질문 후 결과 확인</br>
>   “이 중에서 가장 좋은 질문은 무엇이며, 이유는?”
> - AI가 제시한 이유를 읽어보고, 좋은 프롬프트 특징 최소 1개 이상 메모
> - (추가로, 발견한 특징을 팀원들과 공유하면 더 좋음)


**💡 배경**

- AI는 입력된 프롬프트의 품질에 따라 답변의 정확도와 깊이가 크게 달라짐.
- 개발자에게 중요한 역량 중 하나는 좋은 질문을 던지는 능력이며, 이를 위해 다양한 질문 방식을 시도해보고 차이를 경험하는 것이 필요하다고 생각.

**💡 목적**

- 동일한 주제를 AI에게 여러 방식으로 질문하고, 어떤 질문이 가장 좋은 답변을 이끌어내는지 확인.
- 좋은 프롬프트가 갖추어야 할 요소(맥락, 구체성, 단계적 요구 등)를 직접 체감하고, 효과적인 질문이 뭘 지 감을 찾아가는 것.

---

### 3. 개념을 잘 이해했는지 물어보기

**💡 달성 기준**
> - 개념을 학습한 것을 정리
> - AI에게 잘 이해한 것인지 질문하기
> - 검토받은 내용을 기반으로 학습 내용 다시 정리


**💡 배경**

- 개념을 잘 설명할 수 있으면 그 개념에 대한 이해도를 높일 수 있음. 
- AI와 토론하며 개념을 이해할 수 있는 도구로 활용하면 학습과 성장에 도움이 될 것으로 보임
- 학습과 성장의 도구로 AI를 활용하는 사례가 될 수 있음


**💡 목적**

- AI에게 이해한 것을 설명하여 내가 그 개념을 잘 알고 있는지 메타인지를 할 수 있는 도구로 활용
- 설명하는 행위 자체로도 개념 이해에 많은 도움이 됨

---

### 4. AI에게 할 질문 내용 개선 요청하기

**💡 달성 기준**
> - 하루에 한 번
> - AI에게 질문하기 전에
> - 그 질문이 효과적인지  AI에게 물어보고
> - 그렇지 않다면 개선해달라고 요청한다.
> - 기존의 질문을 가지고 질문한다.
> - 개선된 질문을 가지고 질문한다.
> - 각각의 질문과 답변을 양식에 기록한다.
> - 각각의 답변의 차이에 대해 양식에 기록한다.
> - 기록한 양식을 링크로 공유한다.

[예시](https://docs.google.com/document/d/1_3KtkESluOEbdcso9SEwdoU6z-hWXg8EomyL4iuBwAU/edit?tab=t.flnm3br5nrex)

[양식](https://docs.google.com/document/d/1liia1Rir4WXHZqQj3PhQQGDTKVhUbv7yIMhZ15aX4LE/edit?tab=t.0)

**💡 배경**

- 효율적인 학습 및 AI의 적절한 활용을 위해, 효과적인 프롬프트의 작성은, 개발자들에게 있어서 중요한 역량으로 대두되고 있는 추세이다.

**💡 목적**

- 더 나은 질문이 무엇인지 AI에게 직접 물어보면서, 프롬프트 작성 능력을 향상시키는 것을 목적으로 한다.


# Week 1 릴레이 프로젝트 수행

> **Team 62**
> 
> J013, J176, J217, S031

## J176

❗️수행할 미션: AI에게 더 좋은 질문 알기

<details>
  
<summary>07.21(월)</summary>

## "SOLID원칙에 대해 알려줘" vs "객체지향의 원칙에 대해 알려줘"
### 어떤 질문이 더 좋은 질문일까?

### 질문의 명확성 비교

| 질문                               | 명확성        | 범위                |
|:------------------------------------|:-------------|:--------------------|
| SOLID원칙에 대해 알려줘              | 매우 명확함   | SOLID 5가지 원칙 한정 |
| 객체지향의 원칙에 대해 알려줘        | 다소 포괄적임 | OOP 전반의 다양한 원칙 |

#### SOLID원칙에 대해 알려줘
- **구체적 주제** 한정 : SOLID라는 5가지 객체지향 설계 원칙을 직접적으로 묻는 질문.
- **관련 정보** : SRP(단일 책임 원칙), OCP(개방 폐쇄 원칙), LSP(리스코프 치환 원칙), ISP(인터페이스 분리 원칙), DIP(의존성 역전 원칙).
- **답변의 초점**이 뚜렷함: 누구나 SOLID에 대해서만 상세하게 설명할 수 있음.

#### 객체지향의 원칙에 대해 알려줘
- **범위가 넓음:** 객체지향 설계에 관련된 여러 원칙(OOP 4대 특성, SOLID, GRASP 등)을 모두 포함할 수 있음.
- **모호성 존재:** 답변하는 사람이나 맥락에 따라 답변이 달라질 수 있음.
- **상황에 따라 다양한 해석**이 가능. 예를 들어, 캡슐화·상속·다형성·추상화와 같은 기본 특성부터 GRASP, SOLID, 그 외 패턴까지 포함될 수 있음.

### 결론: 더 좋은 질문은?

- **더 좋은 질문은 "SOLID원칙에 대해 알려줘"**입니다.
  - 이유: **답변의 범위가 명확하고, 질문자가 원하는 정보가 구체적으로 드러납니다.** 답변하는 입장에서도 정확하게 원하는 정보를 전달할 수 있습니다.
  - 반면, "객체지향의 원칙"은 질문의 스펙트럼이 넓어 원하는 방향과 깊이를 맞추기 어렵기 때문입니다.

### 상황별 활용 팁

- **배경지식이 충분하거나 특정 내용을 명확히 알고 싶을 때**: 구체적으로 “SOLID 원칙” 등 특정 개념을 지정해서 묻는 것이 효과적입니다.
- **전체적 흐름이나 큰 그림이 궁금할 때**: “객체지향의 원칙”처럼 포괄적으로 묻고, 이후 추가 질문을 통해 세부 주제로 좁혀나가는 것도 한 방법입니다.

</details>

<details>

<summary>07.22(화)</summary>

## “Mocha와 Jest를 비교해줘” vs “자바스크립트 단위테스트 라이브러리에 대해 알려줘”  
### 어떤 질문이 더 좋은가?

이 두 질문은 목적과 깊이에 따라 적합성이 다릅니다. 아래에서 각각의 장점을 비교하여 어느 질문이 더 “좋은 질문”인지 상황에 따라 조명합니다.

### 1. "Mocha와 Jest를 비교해줘"
- **장점**
  - 특정 두 프레임워크의 장단점을 명확히 파악할 수 있습니다.
  - 프로젝트에서 도입하거나 대체할 때 의사결정이 쉬워집니다.
  - 실제 개발 현장에서 자주 쓰이는 실질적인 비교 결과를 제공합니다.
  - 다음과 같은 대표적인 차이점과 특성을 빠르게 얻을 수 있습니다.
    - Jest는 설정이 거의 필요 없는 올인원(flush, snapshot, mocking 내장) 솔루션이고 React와 프론트엔드 테스트에 강함
    - Mocha는 더욱 유연하고, 백엔드(Node.js)와 커스텀화가 필요한 환경에 강함
    - 성능이나 에코시스템, 커뮤니티 크기 등도 한눈에 비교 가능
- **적합한 경우**
  - 이미 어느 정도 단위 테스트 도구에 대한 지식이 있으며, 실제 도입 선택이 필요한 상황
  - 특정 프레임워크를 들어본 적이 있고 실질적인 선택이 필요한 경우

### 2. "자바스크립트 단위테스트 라이브러리에 대해 알려줘"
- **장점**
  - 다양한 선택지를 넓게 탐색할 수 있습니다.
  - Mocha, Jest 외에도 Jasmine, AVA, Cypress, QUnit, Testing Library 등 다양한 트렌드와 용도를 폭넓게 파악할 수 있습니다.
  - 각 프레임워크의 특징, 사용처, 인기, 생태계, 커뮤니티 등 전체적인 그림을 얻기에 유리합니다.
- **적합한 경우**
  - 단위 테스트에 처음 입문하거나 전체적인 시장 지형을 알고 싶을 때
  - 프로젝트의 요구사항에 맞춰 최적의 프레임워크를 선정하는 초기 조사 단계

### 표: 질문별 특징 비교

| 질문                          | 목적 및 깊이               | 적합한 상황                                               | 주요 특징                                                            |
|-----------------------------|------------------------|---------------------------------------------------------|--------------------------------------------------------------------|
| Mocha와 Jest를 비교해줘         | 구체적, 실전 중심 비교         | 실질 도입/교체, 선택 대상이 정해져 있을 때                     | 빠른 의사결정 지원, 장/단점 명확, 실무 활용도 높음                       |
| 자바스크립트 단위테스트 라이브러리 소개 | 넓은 범위, 개요 중심            | 입문, 초기 조사, 다양한 선택지 탐색 필요할 때                      | 전체 지형 파악, 여러 대안 제시, 프레임워크별 특징 정리                     |

## 결론: 어떤 질문이 더 좋은가?

- **상황에 따라 다릅니다.**  
  - 이미 JavaScript 테스트 경험이 있고 특정 프레임워크를 놓고 고민 중이라면 "Mocha와 Jest를 비교해줘"가 실질적이고 구체적인 답을 얻기에 더 좋은 질문입니다.
  - 단위 테스트 자체가 낯설거나, 도구 선택 전 폭넓은 조사가 필요한 경우라면 "자바스크립트 단위테스트 라이브러리에 대해 알려줘"가 더 많은 정보를 줄 수 있습니다.

- **실무에서는 "비교 질문"이 더 효율적**
  - 실제로 도입하거나 팀 내에서 표준 도구를 선정해야 할 때는 구체적인 비교 질문이 더 실용적이고 결정에 도움이 됩니다.

- **다양한 대안을 알아야 할 때는 "전체 소개" 질문 적합**
  - 트렌드, 테스트 방식, 각 프레임워크 특징 등 큰 그림을 보려면 "전체 라이브러리 소개" 질문이 적합합니다.

> 즉, **명확한 목적이 있다면 구체적 비교 질문이 더 좋은 질문**이 되고,  
> **지식 습득 및 시장 조사가 목적이라면 폭넓은 소개 질문이 더 효율적**입니다.

</details>

<details>

<summary>07.23(수)</summary>

## 1. 질문 비교

| 질문 | 내용 |
|---|---|
| 함수형 프로그래밍에 대해 알려줘. | 함수형 프로그래밍 전체 개념, 특징, 원리, 이점 등 넓은 범위에 대한 설명 요청 |
| 순수 함수, 불변성, 참조 투명성에 대해 알려줘 | 함수형 프로그래밍의 핵심 개념 3가지를 구체적으로 설명 요청 |

## 2. 각 질문별 답변 예시

### 함수형 프로그래밍에 대해 알려줘

함수형 프로그래밍은 수학의 함수 개념을 바탕으로 하여, **순수 함수(pure function)**와 **불변성(immutability)** 등 특징을 강조하는 프로그래밍 패러다임입니다. 상태 변이(mutation) 없이 데이터를 처리하며, 부수효과(side effect)를 최소화하여 프로그램의 예측 가능성과 안정성을 높입니다.

### 순수 함수, 불변성, 참조 투명성에 대해 알려줘

- **순수 함수(pure function)**: 같은 입력에 대해 항상 같은 출력을 내며, 함수 실행 외부에 영향을 주거나 받지 않는 함수.
- **불변성(immutability)**: 데이터가 한 번 생성된 이후에는 변경될 수 없는 성질로, 변경 시 새로운 값을 생성하여 반환.
- **참조 투명성(referential transparency)**: 어떤 식(expression)을 그 값 자체로 치환해도 프로그램의 결과가 달라지지 않는 성질.

## 3. 더 좋은 질문은?

"**순수 함수, 불변성, 참조 투명성에 대해 알려줘**"가 더 좋은 질문입니다.

### 그 이유

- **구체성**: 원하는 정보가 명확하게 드러나서, 답변자가 핵심을 빠르고 효과적으로 설명할 수 있습니다.
- **학습 효과**: 함수형 프로그래밍을 실질적으로 구성하는 중요한 개념을 직접적으로 이해할 수 있습니다.
- **심층적 이해**: 단순한 개념 소개가 아닌, 각 원리의 용도와 차이점까지 파악할 수 있어 응용에 도움이 됩니다.

반면, "함수형 프로그래밍에 대해 알려줘."는 범위가 넓어 막연한 설명이 될 수 있으며, 구체적인 궁금증 혹은 학습 목적을 만족시키기 어렵습니다. 

## 결론

- **함수형 프로그래밍 전체의 개요**가 궁금하다면 첫 번째 질문도 괜찮지만,
- **핵심 개념의 이해나 실질적 적용**을 원한다면 두 번째 질문이 훨씬 효율적이며, 더 좋은 질문입니다.

</details>

<details>

<summary>07.24(목)</summary>

## 두 질문의 비교 분석

### 첫 번째 질문:  
**"멀티스레드와 레이스 컨디션에 대해 알려줘"**

이 질문은 **멀티스레드**와 **레이스 컨디션**이라는 두 가지 개념에 대해 전반적으로 설명해달라고 요청하는 비교적 포괄적인 질문입니다.

- **멀티스레드**  
  - 하나의 프로세스 내에서 여러 개의 스레드가 동시에 일을 수행하는 방식입니다.
  - 같은 메모리 공간을 여러 스레드가 공유해 자원 낭비가 적고, 동시에 여러 작업을 처리해 효율성과 반응성을 높입니다[1][2][3].
  - 하지만 공유 자원 접근시 동기화 문제가 발생할 수 있음[2][3].

- **레이스 컨디션**  
  - 두 개 이상의 스레드 또는 프로세스가 동시에 하나의 공유 자원에 접근하여, 실행 순서에 따라 결과가 달라지는 현상입니다.
  - 올바른 동기화 없이 동시에 같은 데이터를 읽고 쓰면, 예측 불가한 결과, 오류, 데이터 손상 등이 발생할 수 있습니다[4][5][6].

**장점**  
- 초보자가 관련 주요 개념을 동시에 파악하기 좋음.
- 전반적인 용어와 맥락 정리 가능.

**단점**  
- 각 주제를 깊게 다루기에는 범위가 넓음.
- 구체적인 상황이나 예시가 부족할 수 있음.

### 두 번째 질문:  
**"레이스 컨디션이 발생하는 상황과 병렬 처리에 대해 알려줘"**

이 질문은 **레이스 컨디션의 발생 상황(원인과 예시)**과 **병렬 처리**라는 개념의 작동 원리를 구체적으로 묻습니다.

- **레이스 컨디션 발생 상황**  
  - 두 개 이상 스레드 또는 프로세스가 공통 자원(변수, 파일 등)에 동시에 접근해 발생[4][5].
  - 예를 들어, 각각 다른 스레드가 동시에 동일한 데이터를 수정하려고 할 때 순서에 따라 다른 결과를 얻게 됨[6].
  - 동기화(뮤텍스, 세마포어 등)를 적용하지 않으면 문제가 심화됨[6].

- **병렬 처리**  
  - 여러 작업(프로세스, 스레드 등)을 동일한 시간에 여러 처리 장치(코어, CPU 등)에서 동시에 처리하는 기법[7][8][9].
  - 병렬 처리를 활용하면 작업 속도가 빨라지고, 대량의 데이터를 신속하게 처리할 수 있지만 동기화 문제, 레이스 컨디션 등 새로운 문제가 발생할 수 있음[9].

**장점**  
- 레이스 컨디션이 실제로 어떤 상황에서 발생하는지 학습자가 구체적으로 이해할 수 있음.
- 병렬 처리의 의미와 레이스 컨디션의 연관성을 자연스럽게 익힐 수 있음.
- 예시, 원인, 해결법 등 실질적이고 실무적인 답변 유도 가능.

**단점**  
- 멀티스레드 자체의 구조나 정의 설명이 상대적으로 배경 설명에 그칠 수 있음.

## 어떤 질문이 더 좋은 질문인가?  

**두 번째 질문**이 더 좋은 질문입니다.

### 이유  
1. **구체적 문제 인식**  
   - 단순한 용어 정의가 아니라 레이스 컨디션이 실제 어떤 상황에서 왜 일어나는지, 어떤 문제가 발생하는지 짚어볼 수 있음.
   - 병렬 처리라는 현실적 맥락에서 레이스 컨디션과의 관계를 파악하게 해줌.

2. **실무와 연결성**  
   - 병렬 처리 환경에서 레이스 컨디션이 대표적으로 빈번하게 나타나므로, 원인·사례·방지법 등의 실제 프로그래밍 질문·답변으로 확장하기 용이함.
   - 핵심 원리를 이해할 수 있어 소프트웨어 설계와 개발에 직접적인 도움.

3. **깊이 있는 학습 유도**  
   - 단어나 개념만 나열하는 질문에 비해, 실제 동작 상황과 구체적인 모습을 이해하고, 왜 동기화가 중요한지 알 수 있게 됨.

## 요약 표

| 질문                                                        | 구체성 | 실무적 가치 | 학습 효과 |
|----------------------------------------------------------|------|---------|--------|
| 멀티스레드와 레이스 컨디션                                 | 중간   | 보통     | 보통    |
| 레이스 컨디션이 발생하는 상황과 병렬 처리                 | 높음   | 높음     | 높음    |

### 결론  
**실제로 학습 효율성, 실무 활용, 답변의 깊이 측면에서 "레이스 컨디션이 발생하는 상황과 병렬 처리에 대해 알려줘"가 더 좋은 질문입니다.**  
구체적인 상황 설명을 요청하는 질문일수록, 더 깊은 이해와 효과적인 학습으로 이어질 수 있습니다.

</details>


## J217

❗️수행할 미션: 개념을 잘 이해했는지 물어보기

<details>
  
<summary>7/21(월)</summary>

- 저는 Day6 미션을 진행하면서 혼자 정리한 개념을 검토받고, 다시 더 보완해서 간단히 정리해달라는 퀘스트를 함께 수행해보았습니다.
- 입력 프롬프트
```
- 내가 개념을 학습한 것을 정리해서 너에게 줄거야.
- 내가 정리한 내용을 바탕으로 잘 이해했는지 확인해줘.
- 검토받은 내용을 기반으로 학습 내용을 다시 간단히 정리해줘 아래는 내가 학습한 내용을 정리한거야.
..(인터페이스 구현 vs. 추상 클래스 상속 개념을 정리한 내용)
```
- Claude AI 답변

```
**이해 상태 검토**
전반적으로 잘 정리하셨습니다! 핵심 개념들을 정확하게 파악하고 계십니다. 몇 가지 보완할 점과 정확히 짚고 넘어갈 부분들을 말씀드리겠습니다.

**잘 이해하신 부분:**
인터페이스가 컴파일 타임에만 존재하고 JS 코드를 생성하지 않는다는 점
추상 클래스가 런타임에 실제 JS 클래스를 생성한다는 점
추상 클래스에서 생성자, 기본 구현, 접근 한정자 사용 가능하다는 점
사용 시기에 대한 판단 기준

**보완이 필요한 부분:**
"인터페이스가 값 수준에서 객체, 배열, 함수, 클래스, 클래스 인스턴스를 정의할 수 있다"는 표현이 조금 모호합니다. 더 정확히는 "인터페이스는 객체의 형태, 함수의 시그니처, 클래스의 구조 등 다양한 타입을 정의할 수 있다"고 하는 것이 좋겠습니다.
추상 클래스의 특징 중 "추상 메서드"에 대한 언급이 빠져있습니다. 추상 클래스는 구현이 없는 추상 메서드를 가질 수 있고, 이를 상속받는 클래스에서 반드시 구현해야 합니다.

**학습 내용 간단 정리**
인터페이스 vs 추상 클래스
- 인터페이스 (Interface)
타입의 형태만 정의하는 계약서 역할
컴파일 타임에만 존재, 런타임에는 JS 코드 생성 안함
객체, 함수, 클래스 등 다양한 타입 구조 정의 가능
가볍고 범용적인 타입 체크 용도

- 추상 클래스 (Abstract Class)
클래스만 정의 가능한 특수한 클래스
런타임에 실제 JS 클래스로 컴파일됨
생성자, 기본 구현, 추상 메서드, 접근 한정자 모두 사용 가능
공통 구현을 포함한 상속 구조 설계 시 사용

- 선택 기준
공통 구현이 필요하면 → 추상 클래스
단순히 타입 구조 정의가 목적이면 → 인터페이스

핵심 개념을 잘 이해하고 계시네요!
```

</details>

<details>
  
<summary>7/24(목)</summary>

- Day9 미션을 진행하면서 혼자 정리한 개념을 검토받고, 다시 더 보완해서 간단히 정리해달라는 퀘스트를 함께 수행해보았습니다.

- 입력 프롬프트

```
- 내가 개념을 학습한 것을 정리해서 너에게 줄거야.
- 내가 정리한 내용을 바탕으로 잘 이해했는지 확인해줘.
- 검토받은 내용을 기반으로 학습 내용을 다시 간단히 정리해줘 아래는 내가 학습한 내용을 정리한거야.
..(프로세스와 스레드 개념 정리한 내용)
```

- ChagGPT 답변

```
✅ 1. 이해 확인 및 검토
"일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고,
하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다."

정확한 부분:

"하나의 프로세스는 하나 이상의 스레드를 가진다" → 대부분의 OS에서 **메인 스레드(또는 단일 스레드)**는 기본이며, 멀티스레딩을 통해 여러 개의 스레드를 가질 수 있음.

"하나의 프로그램은 하나 이상의 프로세스를 가질 수 있다" → 맞는 말이지만, 일반적인 프로그램은 하나의 프로세스만 가질 때가 더 많습니다.

수정/보완 포인트:

"하나의 프로그램은 하나 이상의 프로세스를 가진다"는 특정한 경우에만 해당합니다. 예를 들어, 웹 브라우저(크롬 등)는 탭마다 프로세스를 따로 갖는 구조이지만, 대부분의 프로그램은 하나의 프로세스만 실행됩니다.

즉, "항상 그렇다"는 일반화는 피해야 합니다.

✏️ 2. 개념을 바르게 정리한 문장 (요약본)
일반적으로 하나의 프로그램은 실행 시 하나의 프로세스로 동작하며,
하나의 프로세스는 최소 하나의 스레드(보통 메인 스레드)를 갖고,
필요에 따라 여러 개의 스레드(멀티스레드)로 확장될 수 있다.
```

</details>


## S031

❗️수행할 미션: 하루 1회 회고하기


